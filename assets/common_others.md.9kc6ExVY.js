import{_ as n,C as s,c as o,o as t,aA as r,G as a}from"./chunks/framework.BPt_yMNM.js";const p="/assets/Windows%20Terminal%20in%20ms-store.CPRsWaIG.png",h="/assets/Windows%20Terminal.kMe8SEsp.png",d="/assets/edit.IXz8gHsa.png",c="/assets/Windows-Terminal-OpenNewTab-admin.BALlQv9X.png",k="/assets/Windows-Terminal-admin.BqVil0sJ.png",m="/assets/PowerShell-auto-completion.CmKqgMxN.png",u="/assets/starship-wsl.C2oln3xg.png",E=JSON.parse('{"title":"杂项","description":"","frontmatter":{},"headers":[],"relativePath":"common/others.md","filePath":"common/others.md","lastUpdated":1764937796000}'),b={name:"common/others.md"};function w(g,e,y,P,S,f){const i=s("NolebaseGitContributors"),l=s("NolebaseGitChangelog");return t(),o("div",null,[e[0]||(e[0]=r('<h1 id="杂项" tabindex="-1">杂项 <a class="header-anchor" href="#杂项" aria-label="Permalink to &quot;杂项&quot;">​</a></h1><h2 id="windows-terminal" tabindex="-1">Windows Terminal <a class="header-anchor" href="#windows-terminal" aria-label="Permalink to &quot;Windows Terminal&quot;">​</a></h2><p>Windows Terminal 是一个 Windows 官方的、支持多标签页的终端软件。</p><p><img src="'+p+'" alt="Microsoft Store中的Windows Terminal" data-zoomable="true"></p><p>Windows Terminal为Windows提供了一个全新的多标签页终端应用程序，并且拥有对WSL的支持，可以快速打开WSL的Linux终端。</p><p><img src="'+h+'" alt="Windows Terminal" data-zoomable="true"></p><p>比较方便，建议使用，用过都说好~</p><h2 id="windows-上的终端编辑器-edit" tabindex="-1">Windows 上的终端编辑器 Edit <a class="header-anchor" href="#windows-上的终端编辑器-edit" aria-label="Permalink to &quot;Windows 上的终端编辑器 Edit&quot;">​</a></h2><p>微软也知道记事本已经变得越来越臃肿，甚至都要支持 Markdown，想想其实挺诡异的——毕竟记事本当个记事本就好了，整这些干什么呢？</p><p>于是，在最新的系统中，Windows 添加了一个基于终端的文本编辑器 Edit。只需要在 PowerShell 中输入 <code>edit</code> 即可。</p><p><img src="'+d+'" alt="edit" data-zoomable="true"></p><p>或者使用 <code>edit filename.txt</code> 打开 <code>filename.txt</code>，<a href="/common/vim.html">其实和 vim 差不多</a>，对吧~</p><p>edit 的标题栏文本其实是可以直接用鼠标点击的，也可以直接用鼠标点击移动光标位置，也就是一个事实上的记事本，并且还更快。</p><p>哎微软。</p><h2 id="powertoys" tabindex="-1">PowerToys <a class="header-anchor" href="#powertoys" aria-label="Permalink to &quot;PowerToys&quot;">​</a></h2><p>PowerToys 是微软官方的 Windows 实用工具集合。这些工具都非常有用，其中一些尤其有用，没用的也可以关闭从而不影响正常使用。</p><p>多说无益，可以前往微软的文档查看 PowerToys 的功能：<a href="https://learn.microsoft.com/zh-cn/windows/powertoys/" target="_blank" rel="noreferrer">https://learn.microsoft.com/zh-cn/windows/powertoys/</a></p><p>如需安装：</p><ul><li>从 <a href="https://learn.microsoft.com/zh-cn/windows/powertoys/" target="_blank" rel="noreferrer">GitHub Release</a> 中获取最新版本的安装程序；</li><li>从 Microsoft Store 中搜索并下载；</li><li>使用 <code>winget install --id Microsoft.PowerToys --source winget</code> 下载。</li></ul><h2 id="powershell" tabindex="-1">PowerShell <a class="header-anchor" href="#powershell" aria-label="Permalink to &quot;PowerShell&quot;">​</a></h2><p>PowerShell 是 Windows 的新一代命令行，它的上一代是 CMD（命令提示符）。你可以在 Microsoft Store 中获取最新版本的 Windows PowerShell。</p><p>最新版本的 PowerShell 是 7.x 版本，不只局限于 Windows，而是可以在 Windows、Linux 和 macOS 上跨平台的现代化版本；而 Windows 预装的 PowerShell （或者没有预装）则是 Windows PowerShell，版本为 5.1 左右。</p><p>PowerShell 拥有自己的一套语法和命令，但是高度兼容 Linux Bash 命令。PowerShell 也可以用于编写脚本，脚本格式后缀为 <code>.ps1</code>。</p><div class="tip custom-block"><p class="custom-block-title">猜猜看为什么不是 <code>.ps</code>？</p><p>是呀是呀，为什么呢？</p><p><s>应该不会是因为有一款软件叫 Adobe Photoshop 吧……</s></p></div><h3 id="以管理员身份运行" tabindex="-1">以管理员身份运行 <a class="header-anchor" href="#以管理员身份运行" aria-label="Permalink to &quot;以管理员身份运行&quot;">​</a></h3><p>在 Windows Terminal 中可以很方便地多开终端，表扬微软。</p><p><img src="'+c+'" alt="Windows Terminal 打开新标签（以管理员身份）" data-zoomable="true"></p><p>按住 <code>Ctrl</code> 并单击 PowerShell，就可以以管理员身份打开新的 PowerShell 终端窗口了。一般来说，这时系统会请求一次 UAC。</p><p>管理员身份打开的终端会在新的 Windows Terminal 窗口中打开，这个窗口的左上角有一个管理员身份的标识，用作区分。</p><p><img src="'+k+`" alt="Windows Terminal 管理员身份" data-zoomable="true"></p><h3 id="允许运行脚本" tabindex="-1">允许运行脚本 <a class="header-anchor" href="#允许运行脚本" aria-label="Permalink to &quot;允许运行脚本&quot;">​</a></h3><p>PowerShell <strong>默认拒绝运行脚本</strong>，因为脚本中可能包含有害命令。但是很多时候我们都需要运行脚本呀，比如说启用 Python venv 工具创建的虚拟环境的时候？</p><p>可以在管理员身份运行的 PowerShell 中输入 <code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned</code> 来更改脚本执行策略。该命令会将脚本执行策略更改为：运行远程脚本需要签名，运行本地脚本无需签名。这样就可以愉快地运行脚本啦。</p><p>使用 <code>Get-ExecutionPolicy</code> 可以获取当前的 PowerShell 脚本执行策略。默认为 <code>Restricted</code>，即拒绝运行所有脚本。</p><p>无论脚本运行策略如何，在 PowerShell 终端中进行交互都是可以进行的。</p><h3 id="设置智能补全" tabindex="-1">设置智能补全 <a class="header-anchor" href="#设置智能补全" aria-label="Permalink to &quot;设置智能补全&quot;">​</a></h3><p>PowerShell 应当已经自带了 PSReadLine 模块，这个模块可以提供体验更加的智能补全。使用 <code>Get-Module PSReadLine</code> 获取此模块，如果能打印出版本信息则已安装。</p><p>如果没有安装，则需要使用 <code>Install-Module PSReadLine</code> 安装此模块。</p><p>想要启用这个模块，你需要编辑 PowerShell 的配置文件。输入 <code>$profile</code> 可以获取当前的 PowerShell 配置文件。（<code>$profile</code> 和 <code>$PROFILE</code> 是等价的~）</p><div class="language-powershell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 按下 Tab 时自动补全</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Set-PSReadlineKeyHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Key Tab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function MenuComplete</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用键盘⬆️和⬇️获取不同的补全</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Set-PSReadlineKeyHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Key UpArrow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function HistorySearchBackward</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Set-PSReadlineKeyHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Key DownArrow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function HistorySearchForward</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 自动补全</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Import-Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PSReadLine</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Set-PSReadLineOption</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PredictionSource History</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>使用你高兴的方法编辑这个配置文件，例如 <code>edit $profile</code>，然后将上面的内容复制进去，保存后退出。</p><p>打开一个新的 PowerShell 终端，现在你可以在其中得到基本的自动补全了：使用 <code>Tab</code> 查询补全 Cmdlet，方向键选择：</p><p><img src="`+m+'" alt="PowerShell Auto Completion" data-zoomable="true"></p><p>以及，使用上下方向键输入历史命令，所有终端都具备的功能。</p><p>PowerShell 会用灰色显示历史命令中与当前输入的部分匹配的输入的剩余部分，此时可以使用键盘上的右方向键向右侧逐词补全。有些反直觉的是，如果此时使用 <code>Tab</code>，有可能补全的内容与灰色内容不相同，这……<s>没救了不是</s></p><h3 id="基本命令与-cmdlet" tabindex="-1">基本命令与 Cmdlet <a class="header-anchor" href="#基本命令与-cmdlet" aria-label="Permalink to &quot;基本命令与 Cmdlet&quot;">​</a></h3><p>Cmdlet 是什么？PowerShell 中设计了一系列由 <code>动词-名词</code> 构成的命令，例如 <code>Get-Help</code> <code>Get-Process</code> 等，这些命令不像 Linux Bash 中的 <code>ls</code> <code>cd</code> 等是可执行文件的链接，只是命令，被称作 Cmdlet。</p><p>记这些命令对于我们来说难度太大了，好在微软是个好人，帮我们降低学习门槛——</p><p>以下命令在 Linux Bash 和 PowerShell 中效果相同或相似。实际上，是微软将这些 Bash 命令链接为了 PowerShell 命令的别名。</p><ul><li><code>cd</code> - 前往指定目录；</li><li><code>ls</code> - 查看当前目录下文件；</li><li><code>echo</code> - 在终端输出内容；</li></ul><p>下面这些命令就是打开对应的可执行文件了，例如 <code>code</code> 是 VSCode：</p><ul><li><code>edit</code> - 使用 Edit 工具打开文件，可参见上文的 Edit；</li><li><code>code</code> - 使用 VSCode 打开文件，<a href="/common/ide.html#visual-studio-code">自然需要先安装 VSCode</a>；</li></ul><h2 id="linux-上的第三方-shell-fish" tabindex="-1">Linux 上的第三方 shell Fish <a class="header-anchor" href="#linux-上的第三方-shell-fish" aria-label="Permalink to &quot;Linux 上的第三方 shell Fish&quot;">​</a></h2><p>Fish <s>（鱼）</s> （Friendly Interactive Shell，交互友好型终端）是一个可在 Linux 和 macOS 上使用的第三方 shell。</p><p>网站：<a href="https://fishshell.com/" target="_blank" rel="noreferrer">https://fishshell.com/</a></p><p>Shell 与终端并不相同。Shell 是与操作系统内核交互的，从终端接收用户输入，将系统的处理结果返还给终端输出给用户。Linux 和 macOS 都是基于 Unix 的操作系统，Unix 拥有默认 shell Bash，而 macOS 还提供了不少其他的 shell 作为可选项。</p><p>但是 Bash 本身并不方便，它缺少智能补全、语法高亮，交互也不够友好，所以才会出现众多第三方的 shell，比如本段落的主角 fish。fish 是那种可以让人眼前一亮的 shell，拥有比 PowerShell 还人性化的交互逻辑，除了它并不完全兼容 Bash 语法之外几乎没有缺点了。<s>不过，这也就是它最大的缺点吧。</s></p><h3 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h3><p>fish 需要从软件包源下载，在不同的 Linux 发行版中命令不同。</p><p>使用 apt 包管理器：<code>sudo apt install fish -y</code></p><p>安装完成后，在当前终端中输入 <code>fish</code> 即可进入 fish shell，然后可以使用 <code>exit</code> 退出。基本的 Linux 命令操作没有改变，如 <code>ls</code> <code>cd</code> 等命令照样用。使用 <code>help</code> 可以获取 fish 的帮助，是一个完整的网页。</p><h3 id="设为默认-shell" tabindex="-1">设为默认 shell <a class="header-anchor" href="#设为默认-shell" aria-label="Permalink to &quot;设为默认 shell&quot;">​</a></h3><p>默认的 Linux shell 为 Bash，其可执行文件位于目录 <code>/usr/bin/bash</code>。fish shell 的可执行文件为 <code>/usr/bin/fish</code>，你可以通过下面的命令将默认 shell 切换为 fish。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chsh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/bin/fish</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或者切换回 Bash。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chsh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/bin/bash</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="全平台终端美化-starship" tabindex="-1">全平台终端美化 starship <a class="header-anchor" href="#全平台终端美化-starship" aria-label="Permalink to &quot;全平台终端美化 starship&quot;">​</a></h2><p>网站：<a href="https://starship.rs/zh-cn/guide/" target="_blank" rel="noreferrer">https://starship.rs/zh-cn/guide/</a></p><p>starship 是一个终端美化工具。</p><p>终端美化的意义远远不止在于好看，而是其能够在美观的同时提供更高效的使用体验。starship 支持显示当前终端所在目录下的项目的基本信息，包括其 Git 分支信息、Python 项目信息、nodejs 版本信息、CMake 项目信息等等。</p><p><img src="'+u+'" alt="starship" data-zoomable="true"></p><h3 id="安装-1" tabindex="-1">安装 <a class="header-anchor" href="#安装-1" aria-label="Permalink to &quot;安装&quot;">​</a></h3><p>以下 Linux Bash 命令可以在任何 Linux 发行版上安装 starship：<code>curl -sS https://starship.rs/install.sh | sh</code></p><p>以下 PowerShell 命令可以在 Windows 上安装 starship：<code>winget install --id Starship.Starship</code></p><p>然后还需要在你的终端中配置默认启用 starship。对于 Bash，在 <code>~/.bashrc</code> 的最后添加一行以下内容，保存并退出。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eval</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">starship</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> init bash)&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>对于 PowerShell，可以直接使用 <code>edit $profile</code> 或 <code>code $profile</code> 或 <code>notepad $profile</code> 来打开它，然后在末尾增加下面一行，保存并退出。</p><div class="language-powershell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Invoke-Expression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">starship init powershell)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>更改后的配置会在新的终端中生效，现在可以把旧的终端都关掉了~</p><h3 id="主题-预设" tabindex="-1">主题（预设） <a class="header-anchor" href="#主题-预设" aria-label="Permalink to &quot;主题（预设）&quot;">​</a></h3><p>starship 拥有多种主题，可以在其文档网站中查看。上面的截图是 <a href="https://starship.rs/zh-CN/presets/jetpack" target="_blank" rel="noreferrer">Jetpack 预设</a>，简单好看 =w。</p><p>在 Linux 中可以使用 <code>starship preset jetpack -o ~/.config/starship.toml</code> 来使用预设。在 Windows 中由于路径问题，可以在新打开的终端中使用 <code>starship preset jetpack -o .config/starship.toml</code>。不过 PowerShell 并不支持该预设需要的右提示词，因此该预设在 PowerShell 中使用体验不佳，建议换一种~</p><p>对于其他的预设同理。</p>',83)),a(i),a(l)])}const F=n(b,[["render",w]]);export{E as __pageData,F as default};
