import{_ as r,y as o,c as l,o as i,aO as s,k as t}from"./chunks/framework.DjmydJ53.js";const f=JSON.parse('{"title":"事件循环与事件","description":"","frontmatter":{},"headers":[],"relativePath":"python/tkinter/eventloop.md","filePath":"python/tkinter/eventloop.md","lastUpdated":1765282507000}'),p={name:"python/tkinter/eventloop.md"};function c(d,e,h,_,m,k){const a=o("NolebaseGitContributors"),n=o("NolebaseGitChangelog");return i(),l("div",null,[e[0]||(e[0]=s('<h1 id="事件循环与事件" tabindex="-1">事件循环与事件 <a class="header-anchor" href="#事件循环与事件" aria-label="Permalink to “事件循环与事件”">​</a></h1><h2 id="什么是事件循环" tabindex="-1">什么是事件循环 <a class="header-anchor" href="#什么是事件循环" aria-label="Permalink to “什么是事件循环”">​</a></h2><p>对于 GUI 应用程序，事件循环是其重要组成部分。</p><p>众所周知，Python 代码是按行解释执行的，这一过程是在单线程中执行的。如果一切正常的话，Python 脚本按行执行下去，几十行代码很快就会结束，程序将会退出。</p><p>然而，我们刚刚观察到，只有在我们手动关闭 Tkinter Hello 窗口之后，Python 解释器才终于退出。这是因为在代码中，我们使用 <code>root.mainloop()</code> 进入了 Tkinter 的事件循环。</p><p>在事件循环中，Tkinter 暂时性地「阻塞」了我们编写的 Python 代码，开始维护我们编写的 GUI 给用户使用，处理用户的输入并进行相应的响应，并且时刻向操作系统汇报我们的程序仍然存活。只有在用户关闭了我们的 Tkinter Hello 窗口之后，代码才得以从 <code>root.mainloop()</code> 继续执行下去，也即程序才退出。</p><p>调用的方法 <code>mainloop()</code> 正是「<strong>主循环</strong>」之意义。</p><h2 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to “事件”">​</a></h2>',8)),t(a),t(n)])}const P=r(p,[["render",c]]);export{f as __pageData,P as default};
