import{ax as l,al as n,z as i,A as r,bn as t,Q as a}from"./chunks/framework.fl0FQG3O.js";const k=JSON.parse('{"title":"面向对象","description":"","frontmatter":{},"headers":[],"relativePath":"common/object-oriented.md","filePath":"common/object-oriented.md","lastUpdated":1741796011000}'),c={name:"common/object-oriented.md"};function b(o,s,d,m,u,h){const e=n("NolebaseGitContributors"),p=n("NolebaseGitChangelog");return r(),i("div",null,[s[0]||(s[0]=t(`<h1 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to “面向对象”">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to “概述”">​</a></h2><p>面向对象，与之相对的是早期语言的面相过程。</p><p>如今的许多主流语言或多或少都是面向对象的语言。如果你觉得这很奇怪，或者对「对象到底有什么好的」这种事感到困惑，那么你需要阅读下面的这些文字。</p><h2 id="在面向对象之前" tabindex="-1">在面向对象之前 <a class="header-anchor" href="#在面向对象之前" aria-label="Permalink to “在面向对象之前”">​</a></h2><p>我们使用伪代码来简单地描述以下情形。伪代码不是任何一门编程语言的合法代码，仅作演示使用。</p><div class="info custom-block"><p class="custom-block-title">编程题</p><p>我校正在举办一个学科组队竞赛，每个队伍的人数在3~6人之间，队伍的得分是队员得分的平均分。</p><p>请编写一个程序，依次接收每个队伍基本信息（队名、队伍编号、人数）的每名成员的得分，然后为接收到的所有队伍排序，按名词顺序输出队伍的基本信息与平均分。</p><p><strong>输入格式</strong>：若共有N支队伍，则输入分为N行，在每一行内依次给出队名、编号与人数，然后是每名队员的得分。</p><p><strong>输出格式</strong>：按照队伍名次排序自高到低输出N行，每行内依次输出名次、队名、编号与均分。</p></div><p>如果我们熟练掌握了一门不支持面向对象的语言，例如C语言，我们可能会写出类似下面的代码：</p><div class="info custom-block"><p class="custom-block-title">在线评测</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>定义 自定义数据结构 team 包括队伍的基本信息与平均分</span></span>
<span class="line"><span>定义 数组 teams</span></span>
<span class="line"><span>while 输入有效:</span></span>
<span class="line"><span>    接收并处理一行输入</span></span>
<span class="line"><span>    定义 _team = 队伍的基本信息与计算得到的平均分</span></span>
<span class="line"><span>    teams.增加数据(_team)</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>teams.排序()</span></span>
<span class="line"><span>for teams中的每一个数据:</span></span>
<span class="line"><span>    打印数据</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></div><p>这样写是完全没有问题的！C语言考试的编程题就该这样写。<strong>在这个程序的编写中，我们采取了面向过程的思维方式</strong>，在代码中描述了一个接收输入、计算排序、依次输出的连续的过程。</p><p>似乎也没什么问题，对吧？</p><h2 id="在面向对象时" tabindex="-1">在面向对象时 <a class="header-anchor" href="#在面向对象时" aria-label="Permalink to “在面向对象时”">​</a></h2><p>让我们首先思考，<strong>对象</strong>是什么东西？</p><p>在上面的编程题中，一支参赛队伍就可以是一个对象。每一支队伍都拥有它的队伍名称、队伍编号、队员数量等信息，这些就是每支队伍的属性。<strong>在面向对象地开发程序时，我们重点关注如何使用代码来描述对象。</strong></p><p>对象不仅可以拥有属性，还可以拥有方法。例如说，参赛队伍拥有增加新队员、移除旧队员的方法（虽然题中没有体现），如果一支队伍的人员发生变动，则队伍属性也会发生变化。</p><p>支持面向对象的语言允许你定义新的<strong>类型</strong>来开始面向对象编程。下面仍然是伪代码：</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>定义 自定义类型 Team</span></span>
<span class="line"><span>    定义 队伍名, 队伍编号, 队伍人数</span></span>
<span class="line"><span>    定义 方法 初始化方法（或者被称为构造函数）(队伍名, 队伍编号, 队伍人数)</span></span>
<span class="line"><span>    定义 方法 增加新队员(...) 无返回</span></span>
<span class="line"><span>    定义 方法 移除旧队员(...) 无返回</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>然后，类似于定义一个字符串类型的变量，我们可以定义一个<code>Team</code>类型的变量，称为将<code>Team</code><strong>实例化</strong>。</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>定义 team = Team(...)</span></span>
<span class="line"><span>// 有的语言可能需要 new 关键字才能实例化，这里不考虑这种差别</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>现在，<code>team</code>对象是<code>Team</code>类型的变量，也是<code>Team</code>的一个实例。</strong></p><h3 id="初始化方法-构造函数" tabindex="-1">初始化方法/构造函数 <a class="header-anchor" href="#初始化方法-构造函数" aria-label="Permalink to “初始化方法/构造函数”">​</a></h3><p>初始化方法是在类被实例化（也就是对象被创建）时运行的方法。原则上，每个类都需要构造方法。</p><p>初始化方法是一个函数，但你无法设置它的返回值，因为它必须返回对象本身。</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>定义 team = Team(...)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在我们实例化类型时，传入的参数实际上被传入到初始化方法中，也就是说我们实际上执行了初始化方法，并在执行后<code>team</code>成为了<code>Team</code>的实例，那么初始化方法只能返回刚刚建立的实例本身。</p><p>当然，你同样可以说初始化方法/构造函数不返回值，只要你理解结果如此即可。</p><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to “继承”">​</a></h3><p>如果我们需要编写多个相似的类，比如宠物猫和宠物狗，它们高度相似，例如都有名字、性别、年龄、毛色等属性，都有睡觉、走路、跑步、恶龙咆哮等方法。</p><p>写重复的代码多没意思，我们不如只写一遍好了。</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>定义 自定义类型 CuteAnimal</span></span>
<span class="line"><span>    定义 名字, 性别, 年龄, 毛色, ...</span></span>
<span class="line"><span>    定义 方法 初始化方法(...)</span></span>
<span class="line"><span>    定义 方法 睡觉() 无返回</span></span>
<span class="line"><span>    定义 方法 走路() 无返回</span></span>
<span class="line"><span>    定义 方法 跑步() 无返回</span></span>
<span class="line"><span>    定义 方法 恶龙咆哮() 返回字符串</span></span>
<span class="line"><span></span></span>
<span class="line"><span>定义 自定义类型 CuteCat 继承 CuteAnimal</span></span>
<span class="line"><span>    定义 方法 初始化方法(...)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>定义 自定义类型 CuteDog 继承 CuteAnimal</span></span>
<span class="line"><span>    定义 方法 初始化方法(...)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上面的伪代码中，<code>CuteCat</code>和<code>CuteDog</code>都是<code>CuteAnimal</code>的子类、派生类，而<code>CuteAnimal</code>是基类、超类、父类。</p><p>继承有两种主要用处，上方是其中一种，即用来构建多个相似的类；另外一种用处是在不修改已有的类本身的情况下修改已有的类，请看下面的伪代码。</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>定义 自定义类型 CuteAnimal</span></span>
<span class="line"><span>    定义 名字, 性别, 年龄, 毛色, ...</span></span>
<span class="line"><span>    定义 方法 初始化方法(...)</span></span>
<span class="line"><span>    定义 方法 睡觉() 无返回</span></span>
<span class="line"><span>    定义 方法 走路() 无返回</span></span>
<span class="line"><span>    定义 方法 跑步() 无返回</span></span>
<span class="line"><span>    定义 方法 恶龙咆哮()</span></span>
<span class="line"><span>        打印 嗷呜嗷呜</span></span>
<span class="line"><span>        返回 嗷呜嗷呜</span></span>
<span class="line"><span></span></span>
<span class="line"><span>定义 自定义类型 CuteCuteAnimal 继承 CuteAnimal</span></span>
<span class="line"><span>    定义 方法 初始化方法(...)</span></span>
<span class="line"><span>    定义 方法 恶龙咆哮()</span></span>
<span class="line"><span>        打印 呜哇呜哇</span></span>
<span class="line"><span>        返回 呜哇呜哇</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义 cat = CuteAnimal(...)</span></span>
<span class="line"><span>定义 cat = CuteCuteAnimal(...)</span></span>
<span class="line"><span>cat.恶龙咆哮()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>也可以在派生类中增加基类中没有的属性或方法。许多语言还要求在派生类中调用基类的初始化方法，不要忘记哦。</p>`,34)),a(e),a(p)])}const C=l(c,[["render",b]]);export{k as __pageData,C as default};
